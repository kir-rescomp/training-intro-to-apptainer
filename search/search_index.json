{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"\u2190 Return to KIR Training Catalogue <p>This lesson provides an introduction to using the Apptainer container platform. Apptainer is particularly suited to running containers on infrastructure where users don\u2019t have administrative privileges, for example shared infrastructure such as High Performance Computing (HPC) clusters.</p> <p>Content</p> <ol> <li>Getting Started with Containers<ul> <li>What is a container and why might I want to use it?</li> </ul> </li> <li>Understanding and Configuring Apptainer Cache and Temporary Directories<ul> <li>Where does Apptainer store images?</li> <li>How do I configure my cache ?</li> </ul> </li> <li>Apptainer Bind - Sharing Data between host and container</li> <li>Apptainer Image Pull and Build<ul> <li>Pull from Docker registry</li> <li>Build from existing local Docker image</li> <li>Build from Apptainer definition file</li> </ul> </li> <li>How to run a container</li> </ol>"},{"location":"1.getting-started-with-containers/","title":"1. Getting Started with Containers","text":""},{"location":"1.getting-started-with-containers/#1-getting-started-with-containers","title":"1. Getting Started with Containers","text":"<p>Overview</p> <p>Questions - What is a container and why might I want to use it?</p> <p>Objectives Understand what a container is and when you might want to use it.</p>"},{"location":"1.getting-started-with-containers/#what-are-containers","title":"What are Containers","text":"<p>A container is an entity providing an isolated software environment (or filesystem) for an application and its dependencies.</p> <p>If you have already used a Virtual Machine, or VM, you\u2019re actually already familiar with some of the concepts of a container.</p> <p></p> <p>The key difference here is that VMs virtualise hardware while containers virtualise operating systems. There are other differences (and benefits), in particular containers are:</p> <ul> <li>lighter weight to run (less CPU and memory usage, faster start-up times)</li> <li>smaller in size (thus easier to transfer and share)</li> <li>modular (possible to combine multiple containers that work together)</li> </ul> <p>Since containers do not virtualise the hardware, containers must be built using the same architecture as the machine they are going to be deployed on. Containers built for one architecture cannot run on the other.</p>"},{"location":"1.getting-started-with-containers/#containers-and-your-workflow","title":"Containers and your workflow","text":"<p>There are a number of reasons for using containers in your daily work:</p> <ul> <li>Data reproducibility/provenance</li> <li>Cross-system portability</li> <li>Simplified collaboration</li> <li>Simplified software dependencies and management</li> <li>Consistent testing environment</li> </ul>"},{"location":"1.getting-started-with-containers/#terminology","title":"Terminology","text":"<p>We\u2019ll start with a brief note on the terminology used in this section of the course. We refer to both images and containers. What is the distinction between these two terms?</p> <p>Images are bundles of files including an operating system, software and potentially data and other application-related files. They may sometimes be referred to as a disk image or container image and they may be stored in different ways, perhaps as a single file, or as a group of files. Either way, we refer to this file, or collection of files, as an image.</p> <p>A container is a virtual environment that is based on an image. That is, the files, applications, tools, etc that are available within a running container are determined by the image that the container is started from. It may be possible to start multiple container instances from an image. You could, perhaps, consider an image to be a form of template from whi***ch running container instances can be started.</p> <p>A registry is a server application where images are stored and can be accessed by users. It can be public (e.g. Docker Hub) or private.</p> <p>To build an image we need a recipe. A recipe file is called a Definition File, or def file, in the Apptainer jargon and a Dockerfile in the Docker world.</p>"},{"location":"1.getting-started-with-containers/#container-engines","title":"Container engines","text":"<p>A number of tools are available to create, deploy and run containerised applications. Some of these will be covered throughout this tutorial:</p> <ul> <li> <p></p><p></p> <p>Docker</p> <p>The first engine to gain popularity, still widely used in the IT industry. Not very suitable for HPC as it requires root privileges to run.</p> </li> <li> <p></p><p></p> <p>Singularity</p> <p>A simple, powerful root-less container engine for the HPC world. Originally developed at the Lawrence Berkeley National Laboratory.</p> <p>SingularityCE is a community driven fork of the original Singularity project, </p> </li> <li> <p></p><p></p> <p>Apptainer</p> <p>A simple, powerful root-less container engine for the HPC world. Originally developed at the Lawrence Berkeley National Laboratory. Successor of Singularity with renaming in 2021.</p> </li> </ul>"},{"location":"2.configuring-apptainer-cache/","title":"2. Understanding and Configuring Apptainer Cache and Temporary Directories","text":""},{"location":"2.configuring-apptainer-cache/#2-understanding-and-configuring-apptainer-cache-and-temporary-directories","title":"2. Understanding and Configuring Apptainer Cache and Temporary Directories","text":""},{"location":"2.configuring-apptainer-cache/#why-this-matters","title":"Why This Matters","text":"<p>By default, Apptainer will attempt to use your home directory for all operations, creating a hidden directory <code>~/.apptainer</code> for this purpose. Since home directories are limited to 20GB, we recommend redirecting these operations to the nobackup filesystem to avoid quota issues.</p>"},{"location":"2.configuring-apptainer-cache/#what-are-these-directories","title":"What Are These Directories?","text":""},{"location":"2.configuring-apptainer-cache/#apptainer_cachedir-local-cache-directory","title":"<code>APPTAINER_CACHEDIR</code> (Local Cache Directory)","text":"<p>This is where Apptainer stores downloaded container images, layers, and other reusable components. When you pull a container image from a registry (like Docker Hub or Sylabs Cloud), Apptainer downloads and caches the image layers here. The cache helps speed up subsequent operations by avoiding redundant downloads. Over time, this directory can grow significantly, especially if you work with multiple large container images.</p>"},{"location":"2.configuring-apptainer-cache/#apptainer_tmpdir-temporary-directory","title":"<code>APPTAINER_TMPDIR</code> (Temporary Directory)","text":"<p>This directory is used for temporary files during container build and execution operations. Apptainer uses this space for:</p> <ul> <li>Unpacking and assembling container layers</li> <li>Storing temporary files during container builds</li> <li>Managing overlay filesystems when running containers</li> <li>Other transient operations that require scratch space</li> </ul> <p>These temporary files are typically cleaned up after operations complete, but the directory can require substantial space during active operations, particularly when building large containers.</p>"},{"location":"2.configuring-apptainer-cache/#setting-up-your-environment","title":"Setting Up Your Environment","text":"<p>To configure Apptainer to use  filesystem other than your home directory, set the following environment variables before running Apptainer.</p>"},{"location":"2.configuring-apptainer-cache/#environment-variable-method-recommended","title":"Environment Variable Method (Recommended)","text":"<p>We recommend using <code>scratch</code> file system (<code>/gpfs3/well/kir/scratch/group</code>) for both cache and temporary. </p> <p>code</p> <ol> <li>create a dedicated directory for yourself on scrach ( make sure to replace <code>group</code> with your research group) <pre><code>mkdir -p /gpfs3/well/kir/scratch/group/$USER_apptainer_cache\n</code></pre> <pre><code>export APPTAINER_CACHEDIR=\"/gpfs3/well/kir/scratch/group/$USER_apptainer_cache\"\nexport APPTAINER_TMPDIR=${APPTAINER_CACHEDIR}\n</code></pre></li> </ol> <p>Making Changes Permanent</p> <p>We recommend adding these environment variables to your <code>~/.bashrc</code> file so they're automatically set for all future sessions. This ensures consistent behavior and prevents accidentally filling up your home directory quota.</p> <pre><code>echo 'export APPTAINER_CACHEDIR=\"/gpfs3/well/kir/scratch/group/$USER_apptainer_cache\"' &gt;&gt; ~/.bashrc\necho 'export APPTAINER_TMPDIR=${APPTAINER_CACHEDIR}' &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"2.configuring-apptainer-cache/#symlink-method","title":"Symlink Method","text":"<p>Alternatively you can use <code>symlink</code> for to create a soft link to the scratch</p> <p>code</p> <pre><code># Create apptainer cache folder\nmkdir -p /gpfs3/well/kir/scratch/group/$USER_apptainer_cache\n\n# symlinking\nln -s /gpfs3/well/kir/scratch/group/$USER_apptainer .apptainer\n</code></pre>"},{"location":"2.configuring-apptainer-cache/#cleaning-the-apptainer-image-cache","title":"\ud83e\uddf9 Cleaning the Apptainer image cache","text":"<p>We can remove container images from the cache using the <code>apptainer cache clean</code> command. Running the command without any options will display a warning and ask you to confirm that you want to remove everything from your cache.</p> <pre><code>$  apptainer cache clean\nThis will delete everything in your cache (containers from all sources and OCI blobs).\nHint: You can see exactly what would be deleted by canceling and using the --dry-run option.\nDo you want to continue? [y/N] y\nINFO:    Removing blob cache entry: blobs\nINFO:    Removing blob cache entry: index.json\nINFO:    Removing blob cache entry: oci-layout\nINFO:    No cached files to remove at /gpfs3/well/kir-scratch/sansom/mat611-apptainer-cache/cache/library\nINFO:    Removing oci-tmp cache entry: 21fa01d221dc3926f97e47a50ad2ad9550680d10f504583e5069777b30983832\nINFO:    No cached files to remove at /gpfs3/well/kir-scratch/sansom/mat611-apptainer-cache/cache/shub\nINFO:    No cached files to remove at /gpfs3/well/kir-scratch/sansom/mat611-apptainer-cache/cache/oras\nINFO:    No cached files to remove at /gpfs3/well/kir-scratch/sansom/mat611-apptainer-cache/cache/net\n</code></pre> <ul> <li>You can also remove specific container images or all container images of a particular type. Look at the output of <code>apptainer cache clean --help</code> for more information.</li> </ul>"},{"location":"3.apptainer_bind/","title":"3. Apptainer Bind: Sharing Data Between Host and Container","text":""},{"location":"3.apptainer_bind/#3-apptainer-bind-sharing-data-between-host-and-container","title":"3. Apptainer Bind: Sharing Data Between Host and Container","text":"<p>Apptainer's bind feature allows users to map directories from the host system into the container environment. This is essential for reading or writing data, leveraging host-based filesystems, or sharing results from container jobs.\u200b</p>"},{"location":"3.apptainer_bind/#how-binding-works","title":"How Binding Works","text":"<p>By default, Apptainer binds your home directory and current working directory into containers. You can also specify custom bind mounts using the <code>--bind</code> flag or the environment variable <code>APPTAINER_BIND</code>.\u200b Our recommendation is to use the latter option to bind the full BMRC file system</p> <ul> <li>Set the <code>APPTAINER_BIND</code> variable before launching the container (useful for repeated binds).</li> </ul> <pre><code>export APPTAINER_BIND=\"/gpfs3/well,/gpfs3/users\"\n</code></pre> <p>Making this bind Permanent</p> <p>We recommend adding these environment variable to your <code>~/.bashrc</code> file so they're automatically set for all future sessions</p> <pre><code>echo 'export APPTAINER_BIND=\"/gpfs3/well,/gpfs3/users\"' &gt;&gt; ~/.bashrc\n</code></pre> <p>code</p> <p>One time consumption binding:</p> <pre><code>apptainer shell --bind /path/to/host_folder1:/folder1,/path/to/host_folder2:/folder2 &lt;apptainer-image&gt;.sif\n</code></pre> <p>Best Practices</p> <ul> <li> <p>If the destination is omitted, Apptainer mounts the directory to the same path in the container (e.g., /project \u2192 /project).\u200b</p> </li> <li> <p>Paths must be absolute; relative paths are not accepted.</p> </li> <li> <p>Use binds to access input/output data, reference scripts, or share results with the host system.</p> </li> <li> <p>Bind mounts are a central aspect of making containers practical in HPC environments, facilitating seamless data movement between host and container</p> </li> </ul>"},{"location":"4.apptainer_image_pull_build/","title":"4. Apptainer Image Pull and Build","text":""},{"location":"4.apptainer_image_pull_build/#4-apptainer-image-pull-and-build","title":"4. Apptainer Image Pull and Build","text":"<p>This section covers different methods for creating Apptainer container images. You can build images from Docker registries, local Docker images, or Apptainer definition files.</p> <p>TOC</p> <ul> <li>Pull from Docker Registry</li> <li>Build from Existing Local Docker Image<ul> <li>Step 1: Export Docker Image to tar Archive</li> <li>Step 2: Transfer tar File to BMRC</li> <li>Step 3: Build Apptainer SIF from tar Archive</li> <li>Verifying Your Converted Image</li> </ul> </li> <li>Build from Apptainer Definition File<ul> <li>Definition File Sections Explained</li> <li>Advantages of Definition Files</li> </ul> </li> </ul>"},{"location":"4.apptainer_image_pull_build/#41-pull-from-docker-registry","title":"4.1 Pull from Docker Registry","text":"<p>Docker containers (primarily stored in https://hub.docker.com/) can be pulled as Apptainer container images. For example, if we want to pull a specific container from Docker Hub:</p> <ul> <li> <p>Search and find the container registry in https://hub.docker.com.</p> <ul> <li>For this example, the image we are after is https://hub.docker.com/r/staphb/trimmomatic/tags</li> </ul> </li> <li> <p>Copy the version you prefer with the blue Copy button next to the corresponding tag. We will use <code>latest</code> as an example</p> <ul> <li>It will be in the form of <code>docker pull staphb/trimmomatic:latest</code></li> <li>In order to pull this as an Apptainer image, remove the word <code>pull</code> and create a URL as <code>docker://staphb/trimmomatic:latest</code></li> </ul> </li> <li>Then pull it with <code>apptainer pull &lt;nameforthelocalimage&gt;.sif docker://staphb/trimmomatic:latest</code><ul> <li><code>&lt;nameforthelocalimage&gt;.sif</code> is the name of the file to be saved once pulled. File extension can be anything but it is ideal to use <code>.sif</code> making it easier to identify the container image</li> </ul> </li> </ul> <p>code</p> <pre><code>apptainer pull trimmomatic_0.40.sif docker://staphb/trimmomatic:latest\n</code></pre> <p>Example output: </p><pre><code>\u276f  apptainer pull trimmomatic_0.40.sif docker://staphb/trimmomatic:latest\nINFO:    Converting OCI blobs to SIF format\nINFO:    Starting build...\nINFO:    Fetching OCI image...\n28.2MiB / 28.2MiB [======================================================================================================] 100 % 17.0 MiB/s 0s\n179.6KiB / 179.6KiB [====================================================================================================] 100 % 17.0 MiB/s 0s\n72.0MiB / 72.0MiB [======================================================================================================] 100 % 17.0 MiB/s 0s\nINFO:    Extracting OCI image...\nINFO:    Inserting Apptainer configuration...\nINFO:    Creating SIF file...\n</code></pre><p></p>"},{"location":"4.apptainer_image_pull_build/#42-build-from-existing-local-docker-image","title":"4.2 Build from Existing Local Docker Image","text":"<p>Apptainer supports local Docker image file conversion. This is useful when you have locally built Docker images that are:</p> <ul> <li>Built locally on your personal computer or workstation</li> <li>Not published to any public registry (Docker Hub, etc.)</li> <li>Proprietary or contain sensitive information that cannot be shared publicly</li> <li>Custom-built for specific research workflows</li> </ul> <p>In these cases, you can convert Docker images to Apptainer SIF format for use on HPC systems like BMRC.</p>"},{"location":"4.apptainer_image_pull_build/#step-1-export-docker-image-to-tar-archive","title":"Step 1: Export Docker Image to tar Archive","text":"<p>On your local machine where Docker is installed, export your Docker image to a tar file:</p> <p>code</p> <pre><code># List your local Docker images\ndocker images\n</code></pre> <p>Example output: </p><pre><code>REPOSITORY          TAG       IMAGE ID       CREATED        SIZE\nmyapp               latest    a1b2c3d4e5f6   2 days ago     1.2GB\ncustom-python       3.11      b2c3d4e5f6a7   1 week ago     800MB\n</code></pre><p></p> <pre><code># Export the Docker image to a tar file\ndocker save -o myapp.tar myapp:latest\n</code></pre> <p>For multiple images or specific image IDs: </p><pre><code># Using image ID\ndocker save -o myimage.tar a1b2c3d4e5f6\n\n# Multiple images in one tar file\ndocker save -o multiple_images.tar image1:tag1 image2:tag2\n</code></pre><p></p> <p>File Size Considerations</p> <p>Docker tar archives can be large (often several GB). Make sure you have sufficient disk space both locally and on the destination filesystem.</p>"},{"location":"4.apptainer_image_pull_build/#step-2-transfer-tar-file-to-bmrc","title":"Step 2: Transfer tar File to BMRC","text":"<p>Transfer the tar file to your BMRC account:</p> <p>code</p> <pre><code># Using scp (from your local machine)\nscp myapp.tar username@cluster2.bmrc.ox.ac.uk:/path/to/destination/\n\n# Or using rsync for large files (recommended)\nrsync -avP myapp.tar username@cluster2.bmrc.ox.ac.uk:/path/to/destination/\n</code></pre>"},{"location":"4.apptainer_image_pull_build/#step-3-build-apptainer-sif-from-tar-archive","title":"Step 3: Build Apptainer SIF from tar Archive","text":"<p>On BMRC, convert the tar archive to Apptainer SIF format:</p> <p>code</p> <pre><code># Build SIF from Docker tar archive\napptainer build myapp.sif docker-archive://myapp.tar\n</code></pre> <p>Example output: </p><pre><code>INFO:    Starting build...\nINFO:    Extracting Docker image from archive...\nINFO:    Creating SIF file...\nINFO:    Build complete: myapp.sif\n</code></pre><p></p>"},{"location":"4.apptainer_image_pull_build/#verifying-your-converted-image","title":"Verifying Your Converted Image","text":"<p>After conversion, verify that your Apptainer image works correctly:</p> <p>code</p> <pre><code># Inspect the container metadata\napptainer inspect myapp.sif\n\n# Test by entering a shell\napptainer shell myapp.sif\n\n# Run a test command\napptainer exec myapp.sif &lt;your-command&gt;\n</code></pre>"},{"location":"4.apptainer_image_pull_build/#43-build-from-apptainer-definition-file","title":"4.3 Build from Apptainer Definition File","text":"<p>Apptainer definition files (<code>.def</code> files) are the native way to build Apptainer containers. They provide more control and features specific to HPC environments.</p>"},{"location":"4.apptainer_image_pull_build/#example-definition-file","title":"Example Definition File","text":"<p>Here's an equivalent Apptainer definition file with the same content as the Dockerfile example:</p> <p>code</p> <pre><code>cat &lt;&lt; EOF &gt; myimage.def\nBootStrap: docker\nFrom: ubuntu:20.04\n\n%post\n    # Update and install basic tools\n    apt-get -y update\n    apt-get install -y wget curl\n    apt-get clean\n    rm -rf /var/lib/apt/lists/*\n\n%environment\n    export LANG=C.UTF-8\n    export LC_ALL=C.UTF-8\n\n%runscript\n    echo \"Container started in /workspace\"\n    cd /workspace\n    exec /bin/bash \"$@\"\n\n%labels\n    Author your.email@example.com\n    Version v1.0.0\n\n%help\n    This is a basic Ubuntu 20.04 container with wget and curl installed.\n    Use: apptainer shell myimage.sif\nEOF\n</code></pre>"},{"location":"4.apptainer_image_pull_build/#build-from-definition-file","title":"Build from Definition File","text":"<p>Although BMRC does not have a dedicated sandbox to build containers at the moment, <code>fakeroot</code> is enabled in both the login nodes and compute nodes allowing researchers to build containers as needed.</p> <p>Build a container on a BMRC login node</p> <p>Build command follows the format of <code>apptainer build --force --fakeroot NAME_OF_THE_CONTAINER.sif name_of_the.def</code></p> <p>Important: If you have <code>$APPTAINER_BIND</code> set globally, unset it with <code>unset APPTAINER_BIND</code> for <code>apptainer build</code> commands. Otherwise the build commands will fail as bind mounts set via this environment variable are NOT supported during build operations.</p> <ul> <li>The build process executes in a special, isolated environment and does NOT honor the <code>APPTAINER_BIND</code> or <code>APPTAINER_BINDPATH</code> environment variables.</li> <li>Only directories specified with the <code>--bind</code> argument are recognized and mounted during the build's <code>%post</code> or <code>%test</code> sections, if the destination mount points already exist in the bootstrap image</li> </ul> <pre><code>unset APPTAINER_BIND\n\napptainer build --force --fakeroot myimage.sif myimage.def\n</code></pre> <p>Build a container on BMRC via Slurm job</p> <p>Since some container builds can consume a significant amount of CPUs and memory, our recommendation is to perform these builds via a Slurm job (either interactive or batch queue). Unfortunately, BMRC compute nodes do not have www access by default. Please contact the KIR Research Computing Manager for assistance configuring your environment to allow compute nodes www access.</p>"},{"location":"4.apptainer_image_pull_build/#definition-file-sections-explained","title":"Definition File Sections Explained","text":"<ul> <li>BootStrap: Specifies the bootstrap agent (docker, library, localimage, etc.)</li> <li>From: The base image to start from</li> <li>%post: Commands to execute during build (like RUN in Dockerfile)</li> <li>%environment: Environment variables set at runtime</li> <li>%runscript: Commands executed when container is run with <code>apptainer run</code></li> <li>%labels: Metadata labels for the container</li> <li>%help: Help text displayed with <code>apptainer run-help</code></li> </ul>"},{"location":"4.apptainer_image_pull_build/#advantages-of-definition-files","title":"Advantages of Definition Files","text":"<ol> <li>Reproducibility: Definition files are text-based and version-controllable</li> <li>HPC-specific features: Better integration with HPC environments</li> <li>Sections: Clear separation of build-time and runtime configurations</li> <li>Documentation: Built-in help and label sections</li> </ol>"},{"location":"5.running_a_container_interactive_and_slurm/","title":"5. Running a container, both interactively and via Slurm","text":""},{"location":"5.running_a_container_interactive_and_slurm/#5-running-a-container-both-interactively-and-via-slurm","title":"5. Running a container, both interactively and via Slurm","text":""},{"location":"5.running_a_container_interactive_and_slurm/#interactive-container-usage","title":"Interactive Container Usage","text":""},{"location":"5.running_a_container_interactive_and_slurm/#shell-access","title":"Shell Access","text":"Working with symlinked directories <p>If you are to access the apptainer image directory via a Symlink and execute the upcoming <code>apptainer</code> commands, it will trigger a warning similar to below </p> <pre><code>WARNING: Error changing the container working directory. Using '/users/....' instead: chdir /users/...: no such file or directory\n</code></pre> <p>The issue occurs because:</p> <ol> <li>Your shell resolves the symlink: When you <code>cd symlinkeddir/</code>, your shell follows the symlink and your $PWD becomes <code>/users/...</code> (the symlink path)</li> <li>Apptainer tries to bind the literal path: Apptainer attempts to set the working directory inside the container to match your current $PWD, but it's working with the symlink path <code>/users/...</code></li> <li>The symlink doesn't exist inside the container: Even though you've bound the entire filesystem with <code>APPTAINER_BIND</code>, the symlink itself may not be properly resolved or may not exist in the container's filesystem view</li> </ol> <p>Solutions</p> <ul> <li> <p>Option 1: Always use the absolute paths</p> </li> <li> <p>Option 2 : Use <code>cd -P</code> to resolve symlinks</p> </li> </ul> <ul> <li>To have a look at the contents of your container, you can \"shell\" into it using <code>apptainer shell containername</code> .      <pre><code>apptainer shell trimmomatic_0.40.aif\n</code></pre> Note - Above shell command will enter the shell within the container image. Note the prompt is now prefixed with \"Apptainer\",     <pre><code>Apptainer&gt;\n</code></pre>     Exit the container by running the command <code>exit</code> which will bring you back to the host system      <pre><code>Apptainer&gt; exit\n</code></pre></li> </ul>"},{"location":"5.running_a_container_interactive_and_slurm/#inspect-container","title":"Inspect Container","text":"<ul> <li>To view metadata and configuration details about an Apptainer container image, use <code>apptainer inspect containername</code> <pre><code>apptainer inspect trimmomatic_0.40.aif\n</code></pre></li> </ul>"},{"location":"5.running_a_container_interactive_and_slurm/#execute-commands","title":"Execute Commands","text":"<ul> <li> <p><code>apptainer exec</code> command</p> <ul> <li>The <code>apptainer exec</code> command allows you to run a specific command inside an Apptainer container, making it ideal for executing scripts, tools, or workflows within the container's environment. For example, you can run a Python script or query the container's filesystem without entering an interactive shell. Let't say you have a python script ( let's call it my_tensorflow.py) using Tensorflow libraries  with a help menu and assuming you have Tensorflow container with all required libraries</li> </ul> <pre><code>apptainer exec trimmomatic_0.40.aimg trimmomatic --help\n</code></pre> </li> </ul>"},{"location":"5.running_a_container_interactive_and_slurm/#run-default-script","title":"Run Default Script","text":"<ul> <li>The apptainer <code>run</code> command, on the other hand, is designed to execute the default process defined in the container (such as its runscript), providing a convenient way to start the container's main application or service as intended by its creator. This is commonly used when you want to use the container as a standalone executable.</li> </ul>"},{"location":"5.running_a_container_interactive_and_slurm/#running-containers-via-slurm","title":"Running Containers via Slurm","text":"<p>Slurm template</p> <pre><code>#!/bin/bash -e\n\n#SBATCH --job-name=trimmomatic-via-apptainer\n#SBATCH --time=00:10:00\n#SBATCH --mem=4G\n#SBATCH --cpus-per-task=4\n\n# Run container %runscript\napptainer exec trimmomatic_0.40.aimg trimmomatic --help some_argument\n</code></pre>"},{"location":"5.running_a_container_interactive_and_slurm/#accessing-gpus-via-apptainer","title":"Accessing GPUs via Apptainer","text":"<p>Accessing GPUs via apptainer requires <code>--nv</code> flag</p> <ul> <li> <p>If your Slurm job has requested access to an NVIDIA GPU, an Apptainer container can transparently access it using the <code>--nv</code> flag:</p> <pre><code>apptainer exec --nv my_container.sif\n</code></pre> </li> <li> <p>For an example, </p> <pre><code>apptainer exec --nv tensorflow-latest-gpu.aif my_tensorflow.py some_argument\n</code></pre> </li> </ul>"}]}