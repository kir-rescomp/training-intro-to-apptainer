{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"\u2190 Return to KIR Training Catalogue <p>This lesson provides an introduction to using the Apptainer container platform. Apptainer is particularly suited to running containers on infrastructure where users don\u2019t have administrative privileges, for example shared infrastructure such as High Performance Computing (HPC) clusters.</p> <p>Content</p> <ol> <li>Getting Started with Containers<ul> <li>What is a container and why might I want to use it?</li> </ul> </li> <li>Understanding and Configuring Apptainer Cache and Temporary Directories<ul> <li>Where does Apptainer store images?</li> <li>How do I configure my cache ?</li> </ul> </li> <li>Apptainer Bind - Sharing Data between host and container</li> <li>Pull container images from upstream regisries<ul> <li>How to pull a Docker container as an Apptainer</li> </ul> </li> <li>How to run a container </li> <li>Build an Apptainer</li> </ol>"},{"location":"1.getting-started-with-containers/","title":"1. Getting Started with Containers","text":""},{"location":"1.getting-started-with-containers/#1-getting-started-with-containers","title":"1. Getting Started with Containers","text":"<p>Overview</p> <p>Questions - What is a container and why might I want to use it?</p> <p>Objectives Understand what a container is and when you might want to use it.</p>"},{"location":"1.getting-started-with-containers/#what-are-containers","title":"What are Containers","text":"<p>A container is an entity providing an isolated software environment (or filesystem) for an application and its dependencies.</p> <p>If you have already used a Virtual Machine, or VM, you\u2019re actually already familiar with some of the concepts of a container.</p> <p></p> <p>The key difference here is that VMs virtualise hardware while containers virtualise operating systems. There are other differences (and benefits), in particular containers are:</p> <ul> <li>lighter weight to run (less CPU and memory usage, faster start-up times)</li> <li>smaller in size (thus easier to transfer and share)</li> <li>modular (possible to combine multiple containers that work together)</li> </ul> <p>Since containers do not virtualise the hardware, containers must be built using the same architecture as the machine they are going to be deployed on. Containers built for one architecture cannot run on the other.</p>"},{"location":"1.getting-started-with-containers/#containers-and-your-workflow","title":"Containers and your workflow","text":"<p>There are a number of reasons for using containers in your daily work:</p> <ul> <li>Data reproducibility/provenance</li> <li>Cross-system portability</li> <li>Simplified collaboration</li> <li>Simplified software dependencies and management</li> <li>Consistent testing environment</li> </ul>"},{"location":"1.getting-started-with-containers/#terminology","title":"Terminology","text":"<p>We\u2019ll start with a brief note on the terminology used in this section of the course. We refer to both images and containers. What is the distinction between these two terms?</p> <p>Images are bundles of files including an operating system, software and potentially data and other application-related files. They may sometimes be referred to as a disk image or container image and they may be stored in different ways, perhaps as a single file, or as a group of files. Either way, we refer to this file, or collection of files, as an image.</p> <p>A container is a virtual environment that is based on an image. That is, the files, applications, tools, etc that are available within a running container are determined by the image that the container is started from. It may be possible to start multiple container instances from an image. You could, perhaps, consider an image to be a form of template from whi***ch running container instances can be started.</p> <p>A registry is a server application where images are stored and can be accessed by users. It can be public (e.g. Docker Hub) or private.</p> <p>To build an image we need a recipe. A recipe file is called a Definition File, or def file, in the Apptainer jargon and a Dockerfile in the Docker world.</p>"},{"location":"1.getting-started-with-containers/#container-engines","title":"Container engines","text":"<p>A number of tools are available to create, deploy and run containerised applications. Some of these will be covered throughout this tutorial:</p> <ul> <li> <p></p><p></p> <p>Docker</p> <p>The first engine to gain popularity, still widely used in the IT industry. Not very suitable for HPC as it requires root privileges to run.</p> </li> <li> <p></p><p></p> <p>Singularity</p> <p>A simple, powerful root-less container engine for the HPC world. Originally developed at the Lawrence Berkeley National Laboratory.</p> </li> <li> <p></p><p></p> <p>Apptainer</p> <p>A simple, powerful root-less container engine for the HPC world. Originally developed at the Lawrence Berkeley National Laboratory.</p> </li> </ul>"},{"location":"2.configuring-apptainer-cache/","title":"2. Understanding and Configuring Apptainer Cache and Temporary Directories","text":""},{"location":"2.configuring-apptainer-cache/#2-understanding-and-configuring-apptainer-cache-and-temporary-directories","title":"2. Understanding and Configuring Apptainer Cache and Temporary Directories","text":""},{"location":"2.configuring-apptainer-cache/#why-this-matters","title":"Why This Matters","text":"<p>By default, Apptainer will attempt to use your home directory for all operations, creating a hidden directory <code>~/.apptainer</code> for this purpose. Since home directories are limited to 20GB, we recommend redirecting these operations to the nobackup filesystem to avoid quota issues.</p>"},{"location":"2.configuring-apptainer-cache/#what-are-these-directories","title":"What Are These Directories?","text":""},{"location":"2.configuring-apptainer-cache/#apptainer_cachedir-local-cache-directory","title":"<code>APPTAINER_CACHEDIR</code> (Local Cache Directory)","text":"<p>This is where Apptainer stores downloaded container images, layers, and other reusable components. When you pull a container image from a registry (like Docker Hub or Sylabs Cloud), Apptainer downloads and caches the image layers here. The cache helps speed up subsequent operations by avoiding redundant downloads. Over time, this directory can grow significantly, especially if you work with multiple large container images.</p>"},{"location":"2.configuring-apptainer-cache/#apptainer_tmpdir-temporary-directory","title":"<code>APPTAINER_TMPDIR</code> (Temporary Directory)","text":"<p>This directory is used for temporary files during container build and execution operations. Apptainer uses this space for:</p> <ul> <li>Unpacking and assembling container layers</li> <li>Storing temporary files during container builds</li> <li>Managing overlay filesystems when running containers</li> <li>Other transient operations that require scratch space</li> </ul> <p>These temporary files are typically cleaned up after operations complete, but the directory can require substantial space during active operations, particularly when building large containers.</p>"},{"location":"2.configuring-apptainer-cache/#setting-up-your-environment","title":"Setting Up Your Environment","text":"<p>To configure Apptainer to use  filesystem other than your home directory, set the following environment variables before running Apptainer.</p> <ul> <li>We recommend using <code>scratch</code> file system (<code>/gpfs3/well/kir/scratch/group</code>) for both cache and temporary. </li> </ul> <p>code</p> <ol> <li>create a dedicated directory for yourself on scrach ( make sure to replace <code>group</code> with your research group) <pre><code>mkdir -p /gpfs3/well/kir/scratch/group/$USER_apptainer_cache\n</code></pre> <pre><code>export APPTAINER_CACHEDIR=\"/gpfs3/well/kir/scratch/group/$USER_apptainer_cache\"\nexport APPTAINER_TMPDIR=${APPTAINER_CACHEDIR}\n</code></pre></li> </ol> <p>Making Changes Permanent</p> <p>We recommend adding these environment variables to your <code>~/.bashrc</code> file so they're automatically set for all future sessions. This ensures consistent behavior and prevents accidentally filling up your home directory quota.</p> <pre><code>echo 'export APPTAINER_CACHEDIR=\"/gpfs3/well/kir/scratch/group/$USER_apptainer_cache\"' &gt;&gt; ~/.bashrc\necho 'export APPTAINER_TMPDIR=${APPTAINER_CACHEDIR}' &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"2.configuring-apptainer-cache/#cleaning-the-apptainer-image-cache","title":"\ud83e\uddf9 Cleaning the Apptainer image cache","text":"<p>We can remove container images from the cache using the <code>apptainer cache clean</code> command. Running the command without any options will display a warning and ask you to confirm that you want to remove everything from your cache.</p> <pre><code>$  apptainer cache clean\nThis will delete everything in your cache (containers from all sources and OCI blobs).\nHint: You can see exactly what would be deleted by canceling and using the --dry-run option.\nDo you want to continue? [y/N] y\nINFO:    Removing blob cache entry: blobs\nINFO:    Removing blob cache entry: index.json\nINFO:    Removing blob cache entry: oci-layout\nINFO:    No cached files to remove at /gpfs3/well/kir-scratch/sansom/mat611-apptainer-cache/cache/library\nINFO:    Removing oci-tmp cache entry: 21fa01d221dc3926f97e47a50ad2ad9550680d10f504583e5069777b30983832\nINFO:    No cached files to remove at /gpfs3/well/kir-scratch/sansom/mat611-apptainer-cache/cache/shub\nINFO:    No cached files to remove at /gpfs3/well/kir-scratch/sansom/mat611-apptainer-cache/cache/oras\nINFO:    No cached files to remove at /gpfs3/well/kir-scratch/sansom/mat611-apptainer-cache/cache/net\n</code></pre> <ul> <li>You can also remove specific container images or all container images of a particular type. Look at the output of <code>apptainer cache clean --help</code> for more information.</li> </ul>"},{"location":"3.apptainer_bind/","title":"3. Apptainer Bind: Sharing Data Between Host and Container","text":""},{"location":"3.apptainer_bind/#3-apptainer-bind-sharing-data-between-host-and-container","title":"3. Apptainer Bind: Sharing Data Between Host and Container","text":"<p>Apptainer's bind feature allows users to map directories from the host system into the container environment. This is essential for reading or writing data, leveraging host-based filesystems, or sharing results from container jobs.\u200b</p>"},{"location":"3.apptainer_bind/#how-binding-works","title":"How Binding Works","text":"<p>By default, Apptainer binds your home directory and current working directory into containers. You can also specify custom bind mounts using the <code>--bind</code> flag or the environment variable <code>APPTAINER_BIND</code>.\u200b Our recommendation is to use the latter option to bind the full BMRC file system</p> <ul> <li>Set the <code>APPTAINER_BIND</code> variable before launching the container (useful for repeated binds).</li> </ul> <pre><code>export APPTAINER_BIND=\"/gpfs3/well,/gpfs3/users\"\n</code></pre> <p>Making this bind Permanent</p> <p>We recommend adding these environment variable to your <code>~/.bashrc</code> file so they're automatically set for all future sessions</p> <pre><code>echo 'export APPTAINER_BIND=\"/gpfs3/well,/gpfs3/users\"' &gt;&gt; ~/.bashrc\n</code></pre> <p>Best Practices</p> <ul> <li> <p>If the destination is omitted, Apptainer mounts the directory to the same path in the container (e.g., /project \u2192 /project).\u200b</p> </li> <li> <p>Paths must be absolute; relative paths are not accepted.</p> </li> <li> <p>Use binds to access input/output data, reference scripts, or share results with the host system.</p> </li> <li> <p>Bind mounts are a central aspect of making containers practical in HPC environments, facilitating seamless data movement between host and container</p> </li> </ul>"},{"location":"4.pull_from_upstream/","title":"4. How to pull a container image from an upstream registry such as Docker hub","text":""},{"location":"4.pull_from_upstream/#4-how-to-pull-a-container-image-from-an-upstream-registry-such-as-docker-hub","title":"4. How to pull a container image from an upstream registry such as Docker hub","text":"<p>Docker containers ( primarily stored in https://hub.docker.com/) can be pulled as Apptainer container images. For an example, if we want to pull the latest version of Tensorflow (GPU) container provided by the Tensorflow developers </p> <ul> <li> <p>Search and find the container registry for Trimmomatic in https://hub.docker/com. </p> <ul> <li>image we are after in this instance is https://hub.docker.com/r/staphb/trimmomatic/tags</li> </ul> </li> <li> <p>Copy tthe version you prefer with blue Copy button next to the corresponding tag. We will use <code>latest</code> as an example</p> <ul> <li>It will be in the form of <code>docker pull staphb/trimmomatic:latest</code></li> <li>IN order to pull this as an apptainer, remove the word <code>pull</code> and create a URL as <code>docker://staphb/trimmomatic:latest</code></li> </ul> </li> <li>Then pull it with <code>apptainer pull nameforthelocalimage.aif docker://staphb/trimmomatic:latest</code><ul> <li><code>nameforthelocalimage.aif</code> is the name of the file to be saved once pulled. File extension can be anything but it is ideal to use <code>.aif</code> making it easier to idenity the container image </li> </ul> </li> </ul> <p>code</p> <pre><code>apptainer pull trimmomatic_0.40.aif docker://staphb/trimmomatic:latest\n</code></pre> <pre><code>\u276f  apptainer pull trimmomatic_0.40.aif docker://staphb/trimmomatic:latest\nINFO:    Converting OCI blobs to SIF format\nINFO:    Starting build...\nINFO:    Fetching OCI image...\n28.2MiB / 28.2MiB [======================================================================================================================================================================================================================================] 100 % 17.0 MiB/s 0s\n179.6KiB / 179.6KiB [====================================================================================================================================================================================================================================] 100 % 17.0 MiB/s 0s\n72.0MiB / 72.0MiB [======================================================================================================================================================================================================================================] 100 % 17.0 MiB/s 0s\nINFO:    Extracting OCI image...\nINFO:    Inserting Apptainer configuration...\nINFO:    Creating SIF file...\n[===================================================================================================================================================================================================================================================================] 100 % 0s\n</code></pre>"},{"location":"5.running_a_container_interactive_and_slurm/","title":"5. Running a container, both interactively ( only the shell or inspect ) and via Slurm","text":""},{"location":"5.running_a_container_interactive_and_slurm/#5-running-a-container-both-interactively-only-the-shell-or-inspect-and-via-slurm","title":"5. Running a container, both interactively ( only the <code>shell</code> or <code>inspect</code> ) and via Slurm","text":"<ul> <li> <p>To have a look at the contents of your container, you can \"shell\" into it using <code>apptainer shell containername</code> .      </p><pre><code>apptainer shell trimmomatic_0.40.aif\n</code></pre> Note - Above shell command will enter the shell within the container image. Note the prompt is now prefixed with \"Apptainer\",     <pre><code>Apptainer&gt;\n</code></pre>     Exit the container by running the command <code>exit</code> which will bring you back to the host system      <pre><code>Apptainer&gt; exit\n</code></pre><p></p> </li> <li> <p>To view metadata and configuration details about an Apptainer container image, use <code>apptainer inspect containername</code> </p><pre><code>apptainer inspect trimmomatic_0.40.aif\n</code></pre><p></p> </li> <li> <p><code>apptainer exec</code> command </p> <ul> <li>The <code>apptainer exec</code> command allows you to run a specific command inside an Apptainer container, making it ideal for executing scripts, tools, or workflows within the container\u2019s environment. For example, you can run a Python script or query the container\u2019s filesystem without entering an interactive shell. Let't say you have a python script ( let's call it my_tensorflow.py) using Tensorflow libraries  with a help menu and assuming you have Tensorflow container with all required libraries </li> </ul> <pre><code>apptainer exec trimmomatic_0.40.aimg trimmomatic --help\n</code></pre> </li> <li> <p>The apptainer <code>run</code> command, on the other hand, is designed to execute the default process defined in the container (such as its runscript), providing a convenient way to start the container\u2019s main application or service as intended by its creator. This is commonly used when you want to use the container as a standalone executable.</p> </li> </ul> <p>Slurm template </p> <pre><code>#!/bin/bash -e\n\n#SBATCH --job-name=trimmomatic-via-apptainer\n#SBATCH --time=00:10:00\n#SBATCH --mem=4G\n#SBATCH --cpus-per-task=4\n\n# Run container %runscript\napptainer exec trimmomatic_0.40.aimg trimmomatic --help some_argument\n</code></pre>"},{"location":"5.running_a_container_interactive_and_slurm/#accessing-gpus-via-apptainer","title":"Accessing GPUs via Apptainer","text":"<p>Accessing GPUs via apptainer requires <code>--nv</code> flag</p> <ul> <li> <p>If your Slurm job has requested access to an NVIDIA GPU, an Apptainer container can transparently access it using the <code>--nv</code> flag:</p> <pre><code>apptainer exec --nv my_container.sif\n</code></pre> </li> <li> <p>For an example, </p> <pre><code>apptainer exec --nv tensorflow-latest-gpu.aif my_tensorflow.py some_argument\n</code></pre> </li> </ul>"},{"location":"6.how_to_build_a_container/","title":"6. How to build a container with apptainer build --force --fakeroot","text":""},{"location":"6.how_to_build_a_container/#6-how-to-build-a-container-with-apptainer-build-force-fakeroot","title":"6. How to build a container with <code>apptainer build --force --fakeroot</code>","text":"<p>Although BMRC does not have a dedicated sandbox to build containers at the moment, <code>fakeroot</code> is enabled in both the login nodes and compute nodes allowing researchers to build containers as needed</p> <p>Build a container on a BMRC login node</p> <ul> <li>To illustrate this functionality, create an example container definition file my_container.def from a shell session on NeSI as follows:</li> </ul> <pre><code>cat &lt;&lt; EOF &gt; my_container.def\nBootStrap: docker\nFrom: ubuntu:20.04\n%post\n    apt-get -y update\n    apt-get install -y wget\nEOF\n</code></pre> <ul> <li>Build command follows the format of <code>apptainer build --force --fakeroot NAME_OF_THE_CONTAINER_AFTER_THE_BUILD.aif name_of_the.def</code></li> <li>If you have <code>$APPTAINER_BIND</code> set globally, unset it with <code>unset APPTAINER_BIND</code> for <code>apptainer build</code> commands. Otherwise the <code>build</code> commands will    fail as bind mounts set via this environment variable are NOT supported during build operations<ul> <li>The build process executes in a special, isolated environment and does NOT honor the <code>APPTAINER_BIND</code> or <code>APPTAINER_BINDPATH</code> environment variables.</li> <li>Only directories specified with the <code>--bind</code> argument are recognized and mounted during the build's <code>%post</code> or <code>%test</code> sections, if the destination mount points already exist in the bootstrap image</li> </ul> </li> </ul> <pre><code>unset APPTAINER_BIND\n\napptainer build --force --fakeroot my_container.aif my_container.def\n</code></pre> <p>Build a container on BMRC via Slurm job</p> <ul> <li>Since some container builds can consume a significant amount of CPUs and memory, our recommendation is to perform these builds via a Slurm job (either interactive or batch queue). Unfortunately, BMRC compute nodes do not have www access by default. Please contact the KIR Research Computing Manager for assistance configuring your environment to allow compute nodes www access.</li> </ul>"}]}